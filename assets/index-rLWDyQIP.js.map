{"version":3,"file":"index-rLWDyQIP.js","sources":["../../node_modules/.pnpm/@unocss+core@0.56.5/node_modules/@unocss/core/dist/index.mjs","../../node_modules/.pnpm/@unocss+rule-utils@0.56.5/node_modules/@unocss/rule-utils/dist/index.mjs","../../themes/index.ts"],"sourcesContent":["function escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction escapeSelector(str) {\n  const length = str.length;\n  let index = -1;\n  let codeUnit;\n  let result = \"\";\n  const firstCodeUnit = str.charCodeAt(0);\n  while (++index < length) {\n    codeUnit = str.charCodeAt(index);\n    if (codeUnit === 0) {\n      result += \"\\uFFFD\";\n      continue;\n    }\n    if (codeUnit === 37) {\n      result += \"\\\\%\";\n      continue;\n    }\n    if (codeUnit === 44) {\n      result += \"\\\\,\";\n      continue;\n    }\n    if (\n      // If the character is in the range [\\1-\\1F] (U+0001 to U+001F) or is\n      // U+007F, […]\n      codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || index === 0 && codeUnit >= 48 && codeUnit <= 57 || index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45\n    ) {\n      result += `\\\\${codeUnit.toString(16)} `;\n      continue;\n    }\n    if (\n      // If the character is the first character and is a `-` (U+002D), and\n      // there is no second character, […]\n      index === 0 && length === 1 && codeUnit === 45\n    ) {\n      result += `\\\\${str.charAt(index)}`;\n      continue;\n    }\n    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {\n      result += str.charAt(index);\n      continue;\n    }\n    result += `\\\\${str.charAt(index)}`;\n  }\n  return result;\n}\nconst e = escapeSelector;\n\nfunction toArray(value = []) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction uniq(value) {\n  return Array.from(new Set(value));\n}\nfunction uniqueBy(array, equalFn) {\n  return array.reduce((acc, cur) => {\n    const index = acc.findIndex((item) => equalFn(cur, item));\n    if (index === -1)\n      acc.push(cur);\n    return acc;\n  }, []);\n}\nfunction isString(s) {\n  return typeof s === \"string\";\n}\n\nfunction normalizeCSSEntries(obj) {\n  if (isString(obj))\n    return obj;\n  return (!Array.isArray(obj) ? Object.entries(obj) : obj).filter((i) => i[1] != null);\n}\nfunction normalizeCSSValues(obj) {\n  if (Array.isArray(obj)) {\n    if (obj.find((i) => !Array.isArray(i) || Array.isArray(i[0])))\n      return obj.map((i) => normalizeCSSEntries(i));\n    else\n      return [obj];\n  } else {\n    return [normalizeCSSEntries(obj)];\n  }\n}\nfunction clearIdenticalEntries(entry) {\n  return entry.filter(([k, v], idx) => {\n    if (k.startsWith(\"$$\"))\n      return false;\n    for (let i = idx - 1; i >= 0; i--) {\n      if (entry[i][0] === k && entry[i][1] === v)\n        return false;\n    }\n    return true;\n  });\n}\nfunction entriesToCss(arr) {\n  if (arr == null)\n    return \"\";\n  return clearIdenticalEntries(arr).map(([key, value]) => value != null ? `${key}:${value};` : void 0).filter(Boolean).join(\"\");\n}\nfunction isObject(item) {\n  return item && typeof item === \"object\" && !Array.isArray(item);\n}\nfunction mergeDeep(original, patch, mergeArray = false) {\n  const o = original;\n  const p = patch;\n  if (Array.isArray(p)) {\n    if (mergeArray && Array.isArray(p))\n      return [...o, ...p];\n    else\n      return [...p];\n  }\n  const output = { ...o };\n  if (isObject(o) && isObject(p)) {\n    Object.keys(p).forEach((key) => {\n      if (isObject(o[key]) && isObject(p[key]) || Array.isArray(o[key]) && Array.isArray(p[key]))\n        output[key] = mergeDeep(o[key], p[key], mergeArray);\n      else\n        Object.assign(output, { [key]: p[key] });\n    });\n  }\n  return output;\n}\nfunction clone(val) {\n  let k, out, tmp;\n  if (Array.isArray(val)) {\n    out = Array(k = val.length);\n    while (k--)\n      out[k] = (tmp = val[k]) && typeof tmp === \"object\" ? clone(tmp) : tmp;\n    return out;\n  }\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    out = {};\n    for (k in val) {\n      if (k === \"__proto__\") {\n        Object.defineProperty(out, k, {\n          value: clone(val[k]),\n          configurable: true,\n          enumerable: true,\n          writable: true\n        });\n      } else {\n        out[k] = (tmp = val[k]) && typeof tmp === \"object\" ? clone(tmp) : tmp;\n      }\n    }\n    return out;\n  }\n  return val;\n}\nfunction isStaticRule(rule) {\n  return isString(rule[0]);\n}\nfunction isStaticShortcut(sc) {\n  return isString(sc[0]);\n}\n\nconst attributifyRE = /^\\[(.+?)~?=\"(.*)\"\\]$/;\nconst cssIdRE = /\\.(css|postcss|sass|scss|less|stylus|styl)($|\\?)/;\nconst validateFilterRE = /[\\w\\u00A0-\\uFFFF-_:%-?]/;\nconst CONTROL_SHORTCUT_NO_MERGE = \"$$shortcut-no-merge\";\nfunction isAttributifySelector(selector) {\n  return selector.match(attributifyRE);\n}\nfunction isValidSelector(selector = \"\") {\n  return validateFilterRE.test(selector);\n}\nfunction normalizeVariant(variant) {\n  return typeof variant === \"function\" ? { match: variant } : variant;\n}\nfunction isRawUtil(util) {\n  return util.length === 3;\n}\nfunction notNull(value) {\n  return value != null;\n}\nfunction noop() {\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass TwoKeyMap {\n  constructor() {\n    __publicField$2(this, \"_map\", /* @__PURE__ */ new Map());\n  }\n  get(key1, key2) {\n    const m2 = this._map.get(key1);\n    if (m2)\n      return m2.get(key2);\n  }\n  getFallback(key1, key2, fallback) {\n    let m2 = this._map.get(key1);\n    if (!m2) {\n      m2 = /* @__PURE__ */ new Map();\n      this._map.set(key1, m2);\n    }\n    if (!m2.has(key2))\n      m2.set(key2, fallback);\n    return m2.get(key2);\n  }\n  set(key1, key2, value) {\n    let m2 = this._map.get(key1);\n    if (!m2) {\n      m2 = /* @__PURE__ */ new Map();\n      this._map.set(key1, m2);\n    }\n    m2.set(key2, value);\n    return this;\n  }\n  has(key1, key2) {\n    return this._map.get(key1)?.has(key2);\n  }\n  delete(key1, key2) {\n    return this._map.get(key1)?.delete(key2) || false;\n  }\n  deleteTop(key1) {\n    return this._map.delete(key1);\n  }\n  map(fn) {\n    return Array.from(this._map.entries()).flatMap(([k1, m2]) => Array.from(m2.entries()).map(([k2, v]) => {\n      return fn(v, k1, k2);\n    }));\n  }\n}\nclass BetterMap extends Map {\n  map(mapFn) {\n    const result = [];\n    this.forEach((v, k) => {\n      result.push(mapFn(v, k));\n    });\n    return result;\n  }\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass CountableSet extends Set {\n  constructor(values) {\n    super(values);\n    __publicField$1(this, \"_map\");\n    this._map ?? (this._map = /* @__PURE__ */ new Map());\n  }\n  add(key) {\n    this._map ?? (this._map = /* @__PURE__ */ new Map());\n    this._map.set(key, (this._map.get(key) ?? 0) + 1);\n    return super.add(key);\n  }\n  delete(key) {\n    this._map.delete(key);\n    return super.delete(key);\n  }\n  clear() {\n    this._map.clear();\n    super.clear();\n  }\n  getCount(key) {\n    return this._map.get(key) ?? 0;\n  }\n  setCount(key, count) {\n    this._map.set(key, count);\n    return super.add(key);\n  }\n}\nfunction isCountableSet(value) {\n  return value instanceof CountableSet;\n}\n\nfunction withLayer(layer, rules) {\n  rules.forEach((r) => {\n    if (!r[2])\n      r[2] = { layer };\n    else\n      r[2].layer = layer;\n  });\n  return rules;\n}\n\nconst regexCache = {};\nfunction makeRegexClassGroup(separators = [\"-\", \":\"]) {\n  const key = separators.join(\"|\");\n  if (!regexCache[key])\n    regexCache[key] = new RegExp(`((?:[!@<~\\\\w+:_/-]|\\\\[&?>?:?\\\\S*\\\\])+?)(${key})\\\\(((?:[~!<>\\\\w\\\\s:/\\\\\\\\,%#.$?-]|\\\\[.*?\\\\])+?)\\\\)(?!\\\\s*?=>)`, \"gm\");\n  regexCache[key].lastIndex = 0;\n  return regexCache[key];\n}\nfunction parseVariantGroup(str, separators = [\"-\", \":\"], depth = 5) {\n  const regexClassGroup = makeRegexClassGroup(separators);\n  let hasChanged;\n  let content = str.toString();\n  const prefixes = /* @__PURE__ */ new Set();\n  const groupsByOffset = /* @__PURE__ */ new Map();\n  do {\n    hasChanged = false;\n    content = content.replace(\n      regexClassGroup,\n      (from, pre, sep, body, groupOffset) => {\n        if (!separators.includes(sep))\n          return from;\n        hasChanged = true;\n        prefixes.add(pre + sep);\n        const bodyOffset = groupOffset + pre.length + sep.length + 1;\n        const group = { length: from.length, items: [] };\n        groupsByOffset.set(groupOffset, group);\n        for (const itemMatch of [...body.matchAll(/\\S+/g)]) {\n          const itemOffset = bodyOffset + itemMatch.index;\n          let innerItems = groupsByOffset.get(itemOffset)?.items;\n          if (innerItems) {\n            groupsByOffset.delete(itemOffset);\n          } else {\n            innerItems = [{\n              offset: itemOffset,\n              length: itemMatch[0].length,\n              className: itemMatch[0]\n            }];\n          }\n          for (const item of innerItems) {\n            item.className = item.className === \"~\" ? pre : item.className.replace(/^(!?)(.*)/, `$1${pre}${sep}$2`);\n            group.items.push(item);\n          }\n        }\n        return \"$\".repeat(from.length);\n      }\n    );\n    depth -= 1;\n  } while (hasChanged && depth);\n  let expanded;\n  if (typeof str === \"string\") {\n    expanded = \"\";\n    let prevOffset = 0;\n    for (const [offset, group] of groupsByOffset) {\n      expanded += str.slice(prevOffset, offset);\n      expanded += group.items.map((item) => item.className).join(\" \");\n      prevOffset = offset + group.length;\n    }\n    expanded += str.slice(prevOffset);\n  } else {\n    expanded = str;\n    for (const [offset, group] of groupsByOffset) {\n      expanded.overwrite(\n        offset,\n        offset + group.length,\n        group.items.map((item) => item.className).join(\" \")\n      );\n    }\n  }\n  return {\n    prefixes: Array.from(prefixes),\n    hasChanged,\n    groupsByOffset,\n    // Computed lazily because MagicString's toString does a lot of work\n    get expanded() {\n      return expanded.toString();\n    }\n  };\n}\nfunction collapseVariantGroup(str, prefixes) {\n  const collection = /* @__PURE__ */ new Map();\n  const sortedPrefix = prefixes.sort((a, b) => b.length - a.length);\n  return str.split(/\\s+/g).map((part) => {\n    const prefix = sortedPrefix.find((prefix2) => part.startsWith(prefix2));\n    if (!prefix)\n      return part;\n    const body = part.slice(prefix.length);\n    if (collection.has(prefix)) {\n      collection.get(prefix).push(body);\n      return null;\n    } else {\n      const items = [body];\n      collection.set(prefix, items);\n      return {\n        prefix,\n        items\n      };\n    }\n  }).filter(notNull).map((i) => {\n    if (typeof i === \"string\")\n      return i;\n    return `${i.prefix}(${i.items.join(\" \")})`;\n  }).join(\" \");\n}\nfunction expandVariantGroup(str, separators = [\"-\", \":\"], depth = 5) {\n  const res = parseVariantGroup(str, separators, depth);\n  return typeof str === \"string\" ? res.expanded : str;\n}\n\nconst warned = /* @__PURE__ */ new Set();\nfunction warnOnce(msg) {\n  if (warned.has(msg))\n    return;\n  console.warn(\"[unocss]\", msg);\n  warned.add(msg);\n}\n\nconst defaultSplitRE = /[\\\\:]?[\\s'\"`;{}]+/g;\nconst splitWithVariantGroupRE = /([\\\\:]?[\\s\"'`;<>]|:\\(|\\)\"|\\)\\s)/g;\nfunction splitCode(code) {\n  return code.split(defaultSplitRE);\n}\nconst extractorSplit = {\n  name: \"@unocss/core/extractor-split\",\n  order: 0,\n  extract({ code }) {\n    return splitCode(code);\n  }\n};\n\nfunction createNanoEvents() {\n  return {\n    events: {},\n    emit(event, ...args) {\n      (this.events[event] || []).forEach((i) => i(...args));\n    },\n    on(event, cb) {\n      (this.events[event] = this.events[event] || []).push(cb);\n      return () => this.events[event] = (this.events[event] || []).filter((i) => i !== cb);\n    }\n  };\n}\n\nconst LAYER_DEFAULT = \"default\";\nconst LAYER_PREFLIGHTS = \"preflights\";\nconst LAYER_SHORTCUTS = \"shortcuts\";\nconst LAYER_IMPORTS = \"imports\";\nconst DEFAULT_LAYERS = {\n  [LAYER_IMPORTS]: -200,\n  [LAYER_PREFLIGHTS]: -100,\n  [LAYER_SHORTCUTS]: -10,\n  [LAYER_DEFAULT]: 0\n};\n\nfunction resolveShortcuts(shortcuts) {\n  return toArray(shortcuts).flatMap((s) => {\n    if (Array.isArray(s))\n      return [s];\n    return Object.entries(s);\n  });\n}\nconst __RESOLVED = \"_uno_resolved\";\nfunction resolvePreset(presetInput) {\n  let preset = typeof presetInput === \"function\" ? presetInput() : presetInput;\n  if (__RESOLVED in preset)\n    return preset;\n  preset = { ...preset };\n  Object.defineProperty(preset, __RESOLVED, {\n    value: true,\n    enumerable: false\n  });\n  const shortcuts = preset.shortcuts ? resolveShortcuts(preset.shortcuts) : void 0;\n  preset.shortcuts = shortcuts;\n  if (preset.prefix || preset.layer) {\n    const apply = (i) => {\n      if (!i[2])\n        i[2] = {};\n      const meta = i[2];\n      if (meta.prefix == null && preset.prefix)\n        meta.prefix = toArray(preset.prefix);\n      if (meta.layer == null && preset.layer)\n        meta.layer = preset.layer;\n    };\n    shortcuts?.forEach(apply);\n    preset.rules?.forEach(apply);\n  }\n  return preset;\n}\nfunction resolvePresets(preset) {\n  const root = resolvePreset(preset);\n  if (!root.presets)\n    return [root];\n  const nested = (root.presets || []).flatMap(toArray).flatMap(resolvePresets);\n  return [root, ...nested];\n}\nfunction resolveConfig(userConfig = {}, defaults = {}) {\n  const config = Object.assign({}, defaults, userConfig);\n  const rawPresets = uniqueBy((config.presets || []).flatMap(toArray).flatMap(resolvePresets), (a, b) => a.name === b.name);\n  const sortedPresets = [\n    ...rawPresets.filter((p) => p.enforce === \"pre\"),\n    ...rawPresets.filter((p) => !p.enforce),\n    ...rawPresets.filter((p) => p.enforce === \"post\")\n  ];\n  const sources = [\n    ...sortedPresets,\n    config\n  ];\n  const sourcesReversed = [...sources].reverse();\n  const layers = Object.assign({}, DEFAULT_LAYERS, ...sources.map((i) => i.layers));\n  function getMerged(key) {\n    return uniq(sources.flatMap((p) => toArray(p[key] || [])));\n  }\n  const extractors = getMerged(\"extractors\");\n  let extractorDefault = sourcesReversed.find((i) => i.extractorDefault !== void 0)?.extractorDefault;\n  if (extractorDefault === void 0)\n    extractorDefault = extractorSplit;\n  if (extractorDefault && !extractors.includes(extractorDefault))\n    extractors.unshift(extractorDefault);\n  extractors.sort((a, b) => (a.order || 0) - (b.order || 0));\n  const rules = getMerged(\"rules\");\n  const rulesStaticMap = {};\n  const rulesSize = rules.length;\n  const rulesDynamic = rules.map((rule, i) => {\n    if (isStaticRule(rule)) {\n      const prefixes = toArray(rule[2]?.prefix || \"\");\n      prefixes.forEach((prefix) => {\n        rulesStaticMap[prefix + rule[0]] = [i, rule[1], rule[2], rule];\n      });\n      return void 0;\n    }\n    return [i, ...rule];\n  }).filter(Boolean).reverse();\n  let theme = mergeThemes(sources.map((p) => p.theme));\n  const extendThemes = getMerged(\"extendTheme\");\n  for (const extendTheme of extendThemes)\n    theme = extendTheme(theme) || theme;\n  const autocomplete = {\n    templates: uniq(sources.flatMap((p) => toArray(p.autocomplete?.templates))),\n    extractors: sources.flatMap((p) => toArray(p.autocomplete?.extractors)).sort((a, b) => (a.order || 0) - (b.order || 0)),\n    shorthands: mergeAutocompleteShorthands(sources.map((p) => p.autocomplete?.shorthands || {}))\n  };\n  let separators = getMerged(\"separators\");\n  if (!separators.length)\n    separators = [\":\", \"-\"];\n  const resolved = {\n    mergeSelectors: true,\n    warn: true,\n    blocklist: [],\n    sortLayers: (layers2) => layers2,\n    ...config,\n    presets: sortedPresets,\n    envMode: config.envMode || \"build\",\n    shortcutsLayer: config.shortcutsLayer || \"shortcuts\",\n    layers,\n    theme,\n    rulesSize,\n    rulesDynamic,\n    rulesStaticMap,\n    preprocess: getMerged(\"preprocess\"),\n    postprocess: getMerged(\"postprocess\"),\n    preflights: getMerged(\"preflights\"),\n    autocomplete,\n    variants: getMerged(\"variants\").map(normalizeVariant).sort((a, b) => (a.order || 0) - (b.order || 0)),\n    shortcuts: resolveShortcuts(getMerged(\"shortcuts\")).reverse(),\n    extractors,\n    safelist: getMerged(\"safelist\"),\n    separators,\n    details: config.details ?? config.envMode === \"dev\"\n  };\n  for (const p of sources)\n    p?.configResolved?.(resolved);\n  return resolved;\n}\nfunction mergeConfigs(configs) {\n  const maybeArrays = [\"shortcuts\", \"preprocess\", \"postprocess\"];\n  const config = configs.map((config2) => Object.entries(config2).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: maybeArrays.includes(key) ? toArray(value) : value\n  }), {})).reduce(({ theme: themeA, ...a }, { theme: themeB, ...b }) => {\n    const c = mergeDeep(a, b, true);\n    if (themeA || themeB)\n      c.theme = mergeThemes([themeA, themeB]);\n    return c;\n  }, {});\n  return config;\n}\nfunction mergeThemes(themes) {\n  return themes.map((theme) => theme ? clone(theme) : {}).reduce((a, b) => mergeDeep(a, b), {});\n}\nfunction mergeAutocompleteShorthands(shorthands) {\n  return shorthands.reduce((a, b) => {\n    const rs = {};\n    for (const key in b) {\n      const value = b[key];\n      if (Array.isArray(value))\n        rs[key] = `(${value.join(\"|\")})`;\n      else\n        rs[key] = value;\n    }\n    return {\n      ...a,\n      ...rs\n    };\n  }, {});\n}\nfunction definePreset(preset) {\n  return preset;\n}\n\nconst version = \"0.56.5\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass UnoGenerator {\n  constructor(userConfig = {}, defaults = {}) {\n    this.userConfig = userConfig;\n    this.defaults = defaults;\n    __publicField(this, \"version\", version);\n    __publicField(this, \"_cache\", /* @__PURE__ */ new Map());\n    __publicField(this, \"config\");\n    __publicField(this, \"blocked\", /* @__PURE__ */ new Set());\n    __publicField(this, \"parentOrders\", /* @__PURE__ */ new Map());\n    __publicField(this, \"events\", createNanoEvents());\n    this.config = resolveConfig(userConfig, defaults);\n    this.events.emit(\"config\", this.config);\n  }\n  setConfig(userConfig, defaults) {\n    if (!userConfig)\n      return;\n    if (defaults)\n      this.defaults = defaults;\n    this.userConfig = userConfig;\n    this.blocked.clear();\n    this.parentOrders.clear();\n    this._cache.clear();\n    this.config = resolveConfig(userConfig, this.defaults);\n    this.events.emit(\"config\", this.config);\n  }\n  async applyExtractors(code, id, extracted = /* @__PURE__ */ new Set()) {\n    const context = {\n      original: code,\n      code,\n      id,\n      extracted,\n      envMode: this.config.envMode\n    };\n    for (const extractor of this.config.extractors) {\n      const result = await extractor.extract?.(context);\n      if (!result)\n        continue;\n      if (isCountableSet(result) && isCountableSet(extracted)) {\n        for (const token of result)\n          extracted.setCount(token, extracted.getCount(token) + result.getCount(token));\n      } else {\n        for (const token of result)\n          extracted.add(token);\n      }\n    }\n    return extracted;\n  }\n  makeContext(raw, applied) {\n    const context = {\n      rawSelector: raw,\n      currentSelector: applied[1],\n      theme: this.config.theme,\n      generator: this,\n      variantHandlers: applied[2],\n      constructCSS: (...args) => this.constructCustomCSS(context, ...args),\n      variantMatch: applied\n    };\n    return context;\n  }\n  async parseToken(raw, alias) {\n    if (this.blocked.has(raw))\n      return;\n    const cacheKey = `${raw}${alias ? ` ${alias}` : \"\"}`;\n    if (this._cache.has(cacheKey))\n      return this._cache.get(cacheKey);\n    let current = raw;\n    for (const p of this.config.preprocess)\n      current = p(raw);\n    if (this.isBlocked(current)) {\n      this.blocked.add(raw);\n      this._cache.set(cacheKey, null);\n      return;\n    }\n    const applied = await this.matchVariants(raw, current);\n    if (!applied || this.isBlocked(applied[1])) {\n      this.blocked.add(raw);\n      this._cache.set(cacheKey, null);\n      return;\n    }\n    const context = this.makeContext(raw, [alias || applied[0], applied[1], applied[2], applied[3]]);\n    if (this.config.details)\n      context.variants = [...applied[3]];\n    const expanded = await this.expandShortcut(context.currentSelector, context);\n    const utils = expanded ? await this.stringifyShortcuts(context.variantMatch, context, expanded[0], expanded[1]) : (await this.parseUtil(context.variantMatch, context))?.map((i) => this.stringifyUtil(i, context)).filter(notNull);\n    if (utils?.length) {\n      this._cache.set(cacheKey, utils);\n      return utils;\n    }\n    this._cache.set(cacheKey, null);\n  }\n  async generate(input, options = {}) {\n    const {\n      id,\n      scope,\n      preflights = true,\n      safelist = true,\n      minify = false,\n      extendedInfo = false\n    } = options;\n    const tokens = isString(input) ? await this.applyExtractors(\n      input,\n      id,\n      extendedInfo ? new CountableSet() : /* @__PURE__ */ new Set()\n    ) : Array.isArray(input) ? new Set(input) : input;\n    if (safelist) {\n      this.config.safelist.forEach((s) => {\n        if (!tokens.has(s))\n          tokens.add(s);\n      });\n    }\n    const nl = minify ? \"\" : \"\\n\";\n    const layerSet = /* @__PURE__ */ new Set([LAYER_DEFAULT]);\n    const matched = extendedInfo ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new Set();\n    const sheet = /* @__PURE__ */ new Map();\n    let preflightsMap = {};\n    const tokenPromises = Array.from(tokens).map(async (raw) => {\n      if (matched.has(raw))\n        return;\n      const payload = await this.parseToken(raw);\n      if (payload == null)\n        return;\n      if (matched instanceof Map) {\n        matched.set(raw, {\n          data: payload,\n          count: isCountableSet(tokens) ? tokens.getCount(raw) : -1\n        });\n      } else {\n        matched.add(raw);\n      }\n      for (const item of payload) {\n        const parent = item[3] || \"\";\n        const layer = item[4]?.layer;\n        if (!sheet.has(parent))\n          sheet.set(parent, []);\n        sheet.get(parent).push(item);\n        if (layer)\n          layerSet.add(layer);\n      }\n    });\n    await Promise.all(tokenPromises);\n    await (async () => {\n      if (!preflights)\n        return;\n      const preflightContext = {\n        generator: this,\n        theme: this.config.theme\n      };\n      const preflightLayerSet = /* @__PURE__ */ new Set([]);\n      this.config.preflights.forEach(({ layer = LAYER_PREFLIGHTS }) => {\n        layerSet.add(layer);\n        preflightLayerSet.add(layer);\n      });\n      preflightsMap = Object.fromEntries(\n        await Promise.all(Array.from(preflightLayerSet).map(\n          async (layer) => {\n            const preflights2 = await Promise.all(\n              this.config.preflights.filter((i) => (i.layer || LAYER_PREFLIGHTS) === layer).map(async (i) => await i.getCSS(preflightContext))\n            );\n            const css = preflights2.filter(Boolean).join(nl);\n            return [layer, css];\n          }\n        ))\n      );\n    })();\n    const layers = this.config.sortLayers(Array.from(layerSet).sort((a, b) => (this.config.layers[a] ?? 0) - (this.config.layers[b] ?? 0) || a.localeCompare(b)));\n    const layerCache = {};\n    const getLayer = (layer) => {\n      if (layerCache[layer])\n        return layerCache[layer];\n      let css = Array.from(sheet).sort((a, b) => (this.parentOrders.get(a[0]) ?? 0) - (this.parentOrders.get(b[0]) ?? 0) || a[0]?.localeCompare(b[0] || \"\") || 0).map(([parent, items]) => {\n        const size = items.length;\n        const sorted = items.filter((i) => (i[4]?.layer || LAYER_DEFAULT) === layer).sort((a, b) => {\n          return a[0] - b[0] || (a[4]?.sort || 0) - (b[4]?.sort || 0) || a[5]?.currentSelector?.localeCompare(b[5]?.currentSelector ?? \"\") || a[1]?.localeCompare(b[1] || \"\") || a[2]?.localeCompare(b[2] || \"\") || 0;\n        }).map(([, selector, body, , meta, , variantNoMerge]) => {\n          const scopedSelector = selector ? applyScope(selector, scope) : selector;\n          return [\n            [[scopedSelector ?? \"\", meta?.sort ?? 0]],\n            body,\n            !!(variantNoMerge ?? meta?.noMerge)\n          ];\n        });\n        if (!sorted.length)\n          return void 0;\n        const rules = sorted.reverse().map(([selectorSortPair, body, noMerge], idx) => {\n          if (!noMerge && this.config.mergeSelectors) {\n            for (let i = idx + 1; i < size; i++) {\n              const current = sorted[i];\n              if (current && !current[2] && (selectorSortPair && current[0] || selectorSortPair == null && current[0] == null) && current[1] === body) {\n                if (selectorSortPair && current[0])\n                  current[0].push(...selectorSortPair);\n                return null;\n              }\n            }\n          }\n          const selectors = selectorSortPair ? uniq(selectorSortPair.sort((a, b) => a[1] - b[1] || a[0]?.localeCompare(b[0] || \"\") || 0).map((pair) => pair[0]).filter(Boolean)) : [];\n          return selectors.length ? `${selectors.join(`,${nl}`)}{${body}}` : body;\n        }).filter(Boolean).reverse().join(nl);\n        if (!parent)\n          return rules;\n        const parents = parent.split(\" $$ \");\n        return `${parents.join(\"{\")}{${nl}${rules}${nl}${\"}\".repeat(parents.length)}`;\n      }).filter(Boolean).join(nl);\n      if (preflights) {\n        css = [preflightsMap[layer], css].filter(Boolean).join(nl);\n      }\n      const layerMark = minify ? \"\" : `/* layer: ${layer} */${nl}`;\n      return layerCache[layer] = css ? layerMark + css : \"\";\n    };\n    const getLayers = (includes = layers, excludes) => {\n      return includes.filter((i) => !excludes?.includes(i)).map((i) => getLayer(i) || \"\").filter(Boolean).join(nl);\n    };\n    return {\n      get css() {\n        return getLayers();\n      },\n      layers,\n      matched,\n      getLayers,\n      getLayer\n    };\n  }\n  async matchVariants(raw, current) {\n    const variants = /* @__PURE__ */ new Set();\n    const handlers = [];\n    let processed = current || raw;\n    let applied = true;\n    const context = {\n      rawSelector: raw,\n      theme: this.config.theme,\n      generator: this\n    };\n    while (applied) {\n      applied = false;\n      for (const v of this.config.variants) {\n        if (!v.multiPass && variants.has(v))\n          continue;\n        let handler = await v.match(processed, context);\n        if (!handler)\n          continue;\n        if (isString(handler)) {\n          if (handler === processed)\n            continue;\n          handler = { matcher: handler };\n        }\n        processed = handler.matcher;\n        handlers.unshift(handler);\n        variants.add(v);\n        applied = true;\n        break;\n      }\n      if (!applied)\n        break;\n      if (handlers.length > 500)\n        throw new Error(`Too many variants applied to \"${raw}\"`);\n    }\n    return [raw, processed, handlers, variants];\n  }\n  applyVariants(parsed, variantHandlers = parsed[4], raw = parsed[1]) {\n    const handler = variantHandlers.slice().sort((a, b) => (a.order || 0) - (b.order || 0)).reduceRight(\n      (previous, v) => (input) => {\n        const entries = v.body?.(input.entries) || input.entries;\n        const parents = Array.isArray(v.parent) ? v.parent : [v.parent, void 0];\n        return (v.handle ?? defaultVariantHandler)({\n          ...input,\n          entries,\n          selector: v.selector?.(input.selector, entries) || input.selector,\n          parent: parents[0] || input.parent,\n          parentOrder: parents[1] || input.parentOrder,\n          layer: v.layer || input.layer,\n          sort: v.sort || input.sort\n        }, previous);\n      },\n      (input) => input\n    );\n    const variantContextResult = handler({\n      prefix: \"\",\n      selector: toEscapedSelector(raw),\n      pseudo: \"\",\n      entries: parsed[2]\n    });\n    const { parent, parentOrder } = variantContextResult;\n    if (parent != null && parentOrder != null)\n      this.parentOrders.set(parent, parentOrder);\n    const obj = {\n      selector: [\n        variantContextResult.prefix,\n        variantContextResult.selector,\n        variantContextResult.pseudo\n      ].join(\"\"),\n      entries: variantContextResult.entries,\n      parent,\n      layer: variantContextResult.layer,\n      sort: variantContextResult.sort,\n      noMerge: variantContextResult.noMerge\n    };\n    for (const p of this.config.postprocess)\n      p(obj);\n    return obj;\n  }\n  constructCustomCSS(context, body, overrideSelector) {\n    const normalizedBody = normalizeCSSEntries(body);\n    if (isString(normalizedBody))\n      return normalizedBody;\n    const { selector, entries, parent } = this.applyVariants([0, overrideSelector || context.rawSelector, normalizedBody, void 0, context.variantHandlers]);\n    const cssBody = `${selector}{${entriesToCss(entries)}}`;\n    if (parent)\n      return `${parent}{${cssBody}}`;\n    return cssBody;\n  }\n  async parseUtil(input, context, internal = false, shortcutPrefix) {\n    const [raw, processed, variantHandlers] = isString(input) ? await this.matchVariants(input) : input;\n    if (this.config.details)\n      context.rules = context.rules ?? [];\n    const staticMatch = this.config.rulesStaticMap[processed];\n    if (staticMatch) {\n      if (staticMatch[1] && (internal || !staticMatch[2]?.internal)) {\n        if (this.config.details)\n          context.rules.push(staticMatch[3]);\n        const index = staticMatch[0];\n        const entry = normalizeCSSEntries(staticMatch[1]);\n        const meta = staticMatch[2];\n        if (isString(entry))\n          return [[index, entry, meta]];\n        else\n          return [[index, raw, entry, meta, variantHandlers]];\n      }\n    }\n    context.variantHandlers = variantHandlers;\n    const { rulesDynamic } = this.config;\n    for (const [i, matcher, handler, meta] of rulesDynamic) {\n      if (meta?.internal && !internal)\n        continue;\n      let unprefixed = processed;\n      if (meta?.prefix) {\n        const prefixes = toArray(meta.prefix);\n        if (shortcutPrefix) {\n          const shortcutPrefixes = toArray(shortcutPrefix);\n          if (!prefixes.some((i2) => shortcutPrefixes.includes(i2)))\n            continue;\n        } else {\n          const prefix = prefixes.find((i2) => processed.startsWith(i2));\n          if (prefix == null)\n            continue;\n          unprefixed = processed.slice(prefix.length);\n        }\n      }\n      const match = unprefixed.match(matcher);\n      if (!match)\n        continue;\n      const result = await handler(match, context);\n      if (!result)\n        continue;\n      if (this.config.details)\n        context.rules.push([matcher, handler, meta]);\n      const entries = normalizeCSSValues(result).filter((i2) => i2.length);\n      if (entries.length) {\n        return entries.map((e2) => {\n          if (isString(e2))\n            return [i, e2, meta];\n          else\n            return [i, raw, e2, meta, variantHandlers];\n        });\n      }\n    }\n  }\n  stringifyUtil(parsed, context) {\n    if (!parsed)\n      return;\n    if (isRawUtil(parsed))\n      return [parsed[0], void 0, parsed[1], void 0, parsed[2], this.config.details ? context : void 0, void 0];\n    const { selector, entries, parent, layer: variantLayer, sort: variantSort, noMerge } = this.applyVariants(parsed);\n    const body = entriesToCss(entries);\n    if (!body)\n      return;\n    const { layer: metaLayer, sort: metaSort, ...meta } = parsed[3] ?? {};\n    const ruleMeta = {\n      ...meta,\n      layer: variantLayer ?? metaLayer,\n      sort: variantSort ?? metaSort\n    };\n    return [parsed[0], selector, body, parent, ruleMeta, this.config.details ? context : void 0, noMerge];\n  }\n  async expandShortcut(input, context, depth = 5) {\n    if (depth === 0)\n      return;\n    const recordShortcut = this.config.details ? (s) => {\n      context.shortcuts = context.shortcuts ?? [];\n      context.shortcuts.push(s);\n    } : noop;\n    let meta;\n    let result;\n    for (const s of this.config.shortcuts) {\n      let unprefixed = input;\n      if (s[2]?.prefix) {\n        const prefixes = toArray(s[2].prefix);\n        const prefix = prefixes.find((i) => input.startsWith(i));\n        if (prefix == null)\n          continue;\n        unprefixed = input.slice(prefix.length);\n      }\n      if (isStaticShortcut(s)) {\n        if (s[0] === unprefixed) {\n          meta = meta || s[2];\n          result = s[1];\n          recordShortcut(s);\n          break;\n        }\n      } else {\n        const match = unprefixed.match(s[0]);\n        if (match)\n          result = s[1](match, context);\n        if (result) {\n          meta = meta || s[2];\n          recordShortcut(s);\n          break;\n        }\n      }\n    }\n    if (isString(result))\n      result = expandVariantGroup(result.trim()).split(/\\s+/g);\n    if (!result) {\n      const [raw, inputWithoutVariant] = isString(input) ? await this.matchVariants(input) : input;\n      if (raw !== inputWithoutVariant) {\n        const expanded = await this.expandShortcut(inputWithoutVariant, context, depth - 1);\n        if (expanded)\n          result = expanded[0].map((item) => isString(item) ? raw.replace(inputWithoutVariant, item) : item);\n      }\n    }\n    if (!result)\n      return;\n    return [\n      (await Promise.all(result.map(async (r) => (isString(r) ? (await this.expandShortcut(r, context, depth - 1))?.[0] : void 0) || [r]))).flat(1).filter(Boolean),\n      meta\n    ];\n  }\n  async stringifyShortcuts(parent, context, expanded, meta = { layer: this.config.shortcutsLayer }) {\n    const selectorMap = new TwoKeyMap();\n    const parsed = (await Promise.all(uniq(expanded).map(async (i) => {\n      const result = isString(i) ? await this.parseUtil(i, context, true, meta.prefix) : [[Number.POSITIVE_INFINITY, \"{inline}\", normalizeCSSEntries(i), void 0, []]];\n      if (!result && this.config.warn)\n        warnOnce(`unmatched utility \"${i}\" in shortcut \"${parent[1]}\"`);\n      return result || [];\n    }))).flat(1).filter(Boolean).sort((a, b) => a[0] - b[0]);\n    const [raw, , parentVariants] = parent;\n    const rawStringifiedUtil = [];\n    for (const item of parsed) {\n      if (isRawUtil(item)) {\n        rawStringifiedUtil.push([item[0], void 0, item[1], void 0, item[2], context, void 0]);\n        continue;\n      }\n      const { selector, entries, parent: parent2, sort, noMerge } = this.applyVariants(item, [...item[4], ...parentVariants], raw);\n      const mapItem = selectorMap.getFallback(selector, parent2, [[], item[0]]);\n      mapItem[0].push([entries, !!(noMerge ?? item[3]?.noMerge), sort ?? 0]);\n    }\n    return rawStringifiedUtil.concat(selectorMap.map(([e2, index], selector, joinedParents) => {\n      const stringify = (flatten, noMerge, entrySortPair) => {\n        const maxSort = Math.max(...entrySortPair.map((e3) => e3[1]));\n        const entriesList = entrySortPair.map((e3) => e3[0]);\n        return (flatten ? [entriesList.flat(1)] : entriesList).map((entries) => {\n          const body = entriesToCss(entries);\n          if (body)\n            return [index, selector, body, joinedParents, { ...meta, noMerge, sort: maxSort }, context, void 0];\n          return void 0;\n        });\n      };\n      const merges = [\n        [e2.filter(([, noMerge]) => noMerge).map(([entries, , sort]) => [entries, sort]), true],\n        [e2.filter(([, noMerge]) => !noMerge).map(([entries, , sort]) => [entries, sort]), false]\n      ];\n      return merges.map(([e3, noMerge]) => [\n        ...stringify(false, noMerge, e3.filter(([entries]) => entries.some((entry) => entry[0] === CONTROL_SHORTCUT_NO_MERGE))),\n        ...stringify(true, noMerge, e3.filter(([entries]) => entries.every((entry) => entry[0] !== CONTROL_SHORTCUT_NO_MERGE)))\n      ]);\n    }).flat(2).filter(Boolean));\n  }\n  isBlocked(raw) {\n    return !raw || this.config.blocklist.some((e2) => typeof e2 === \"function\" ? e2(raw) : isString(e2) ? e2 === raw : e2.test(raw));\n  }\n}\nfunction createGenerator(config, defaults) {\n  return new UnoGenerator(config, defaults);\n}\nconst regexScopePlaceholder = /\\s\\$\\$\\s+/g;\nfunction hasScopePlaceholder(css) {\n  return css.match(/\\s\\$\\$\\s/);\n}\nfunction applyScope(css, scope) {\n  if (hasScopePlaceholder(css))\n    return css.replace(regexScopePlaceholder, scope ? ` ${scope} ` : \" \");\n  else\n    return scope ? `${scope} ${css}` : css;\n}\nconst attributifyRe = /^\\[(.+?)(~?=)\"(.*)\"\\]$/;\nfunction toEscapedSelector(raw) {\n  if (attributifyRe.test(raw))\n    return raw.replace(attributifyRe, (_, n, s, i) => `[${e(n)}${s}\"${e(i)}\"]`);\n  return `.${e(raw)}`;\n}\nfunction defaultVariantHandler(input, next) {\n  return next(input);\n}\n\nexport { BetterMap, CONTROL_SHORTCUT_NO_MERGE, CountableSet, TwoKeyMap, UnoGenerator, attributifyRE, clearIdenticalEntries, clone, collapseVariantGroup, createGenerator, cssIdRE, defaultSplitRE, definePreset, e, entriesToCss, escapeRegExp, escapeSelector, expandVariantGroup, extractorSplit as extractorDefault, extractorSplit, hasScopePlaceholder, isAttributifySelector, isCountableSet, isObject, isRawUtil, isStaticRule, isStaticShortcut, isString, isValidSelector, makeRegexClassGroup, mergeConfigs, mergeDeep, noop, normalizeCSSEntries, normalizeCSSValues, normalizeVariant, notNull, parseVariantGroup, regexScopePlaceholder, resolveConfig, resolvePreset, resolvePresets, resolveShortcuts, splitWithVariantGroupRE, toArray, toEscapedSelector, uniq, uniqueBy, validateFilterRE, warnOnce, withLayer };\n","import { isString, escapeRegExp } from '@unocss/core';\n\nfunction getBracket(str, open, close) {\n  if (str === \"\")\n    return;\n  const l = str.length;\n  let parenthesis = 0;\n  let opened = false;\n  let openAt = 0;\n  for (let i = 0; i < l; i++) {\n    switch (str[i]) {\n      case open:\n        if (!opened) {\n          opened = true;\n          openAt = i;\n        }\n        parenthesis++;\n        break;\n      case close:\n        --parenthesis;\n        if (parenthesis < 0)\n          return;\n        if (parenthesis === 0) {\n          return [\n            str.slice(openAt, i + 1),\n            str.slice(i + 1),\n            str.slice(0, openAt)\n          ];\n        }\n        break;\n    }\n  }\n}\nfunction getStringComponent(str, open, close, separators) {\n  if (str === \"\")\n    return;\n  if (isString(separators))\n    separators = [separators];\n  if (separators.length === 0)\n    return;\n  const l = str.length;\n  let parenthesis = 0;\n  for (let i = 0; i < l; i++) {\n    switch (str[i]) {\n      case open:\n        parenthesis++;\n        break;\n      case close:\n        if (--parenthesis < 0)\n          return;\n        break;\n      default:\n        for (const separator of separators) {\n          const separatorLength = separator.length;\n          if (separatorLength && separator === str.slice(i, i + separatorLength) && parenthesis === 0) {\n            if (i === 0 || i === l - separatorLength)\n              return;\n            return [\n              str.slice(0, i),\n              str.slice(i + separatorLength)\n            ];\n          }\n        }\n    }\n  }\n  return [\n    str,\n    \"\"\n  ];\n}\nfunction getStringComponents(str, separators, limit) {\n  limit = limit ?? 10;\n  const components = [];\n  let i = 0;\n  while (str !== \"\") {\n    if (++i > limit)\n      return;\n    const componentPair = getStringComponent(str, \"(\", \")\", separators);\n    if (!componentPair)\n      return;\n    const [component, rest] = componentPair;\n    components.push(component);\n    str = rest;\n  }\n  if (components.length > 0)\n    return components;\n}\n\nconst cssColorFunctions = [\"hsl\", \"hsla\", \"hwb\", \"lab\", \"lch\", \"oklab\", \"oklch\", \"rgb\", \"rgba\"];\nconst alphaPlaceholders = [\"%alpha\", \"<alpha-value>\"];\nconst alphaPlaceholdersRE = new RegExp(alphaPlaceholders.map((v) => escapeRegExp(v)).join(\"|\"));\nfunction hex2rgba(hex = \"\") {\n  const color = parseHexColor(hex);\n  if (color != null) {\n    const { components, alpha } = color;\n    if (alpha == null)\n      return components;\n    return [...components, alpha];\n  }\n}\nfunction parseCssColor(str = \"\") {\n  const color = parseColor(str);\n  if (color == null || color === false)\n    return;\n  const { type: casedType, components, alpha } = color;\n  const type = casedType.toLowerCase();\n  if (components.length === 0)\n    return;\n  if ([\"rgba\", \"hsla\"].includes(type) && alpha == null)\n    return;\n  if (cssColorFunctions.includes(type) && ![1, 3].includes(components.length))\n    return;\n  return {\n    type,\n    components: components.map((c) => typeof c === \"string\" ? c.trim() : c),\n    alpha: typeof alpha === \"string\" ? alpha.trim() : alpha\n  };\n}\nfunction colorOpacityToString(color) {\n  const alpha = color.alpha ?? 1;\n  return typeof alpha === \"string\" && alphaPlaceholders.includes(alpha) ? 1 : alpha;\n}\nfunction colorToString(color, alphaOverride) {\n  if (typeof color === \"string\")\n    return color.replace(alphaPlaceholdersRE, `${alphaOverride ?? 1}`);\n  const { components } = color;\n  let { alpha, type } = color;\n  alpha = alphaOverride ?? alpha;\n  type = type.toLowerCase();\n  if ([\"hsla\", \"hsl\", \"rgba\", \"rgb\"].includes(type))\n    return `${type.replace(\"a\", \"\")}a(${components.join(\",\")}${alpha == null ? \"\" : `,${alpha}`})`;\n  alpha = alpha == null ? \"\" : ` / ${alpha}`;\n  if (cssColorFunctions.includes(type))\n    return `${type}(${components.join(\" \")}${alpha})`;\n  return `color(${type} ${components.join(\" \")}${alpha})`;\n}\nfunction parseColor(str) {\n  if (!str)\n    return;\n  let color = parseHexColor(str);\n  if (color != null)\n    return color;\n  color = cssColorKeyword(str);\n  if (color != null)\n    return color;\n  color = parseCssCommaColorFunction(str);\n  if (color != null)\n    return color;\n  color = parseCssSpaceColorFunction(str);\n  if (color != null)\n    return color;\n  color = parseCssColorFunction(str);\n  if (color != null)\n    return color;\n}\nfunction parseHexColor(str) {\n  const [, body] = str.match(/^#([\\da-f]+)$/i) || [];\n  if (!body)\n    return;\n  switch (body.length) {\n    case 3:\n    case 4:\n      const digits = Array.from(body, (s) => Number.parseInt(s, 16)).map((n) => n << 4 | n);\n      return {\n        type: \"rgb\",\n        components: digits.slice(0, 3),\n        alpha: body.length === 3 ? void 0 : Math.round(digits[3] / 255 * 100) / 100\n      };\n    case 6:\n    case 8:\n      const value = Number.parseInt(body, 16);\n      return {\n        type: \"rgb\",\n        components: body.length === 6 ? [value >> 16 & 255, value >> 8 & 255, value & 255] : [value >> 24 & 255, value >> 16 & 255, value >> 8 & 255],\n        alpha: body.length === 6 ? void 0 : Math.round((value & 255) / 255 * 100) / 100\n      };\n  }\n}\nfunction cssColorKeyword(str) {\n  const color = {\n    rebeccapurple: [102, 51, 153, 1]\n  }[str];\n  if (color != null) {\n    return {\n      type: \"rgb\",\n      components: color.slice(0, 3),\n      alpha: color[3]\n    };\n  }\n}\nfunction parseCssCommaColorFunction(color) {\n  const match = color.match(/^(rgb|rgba|hsl|hsla)\\((.+)\\)$/i);\n  if (!match)\n    return;\n  const [, type, componentString] = match;\n  const components = getStringComponents(componentString, \",\", 5);\n  if (components) {\n    if ([3, 4].includes(components.length)) {\n      return {\n        type,\n        components: components.slice(0, 3),\n        alpha: components[3]\n      };\n    } else if (components.length !== 1) {\n      return false;\n    }\n  }\n}\nconst cssColorFunctionsRe = new RegExp(`^(${cssColorFunctions.join(\"|\")})\\\\((.+)\\\\)$`, \"i\");\nfunction parseCssSpaceColorFunction(color) {\n  const match = color.match(cssColorFunctionsRe);\n  if (!match)\n    return;\n  const [, fn, componentString] = match;\n  const parsed = parseCssSpaceColorValues(`${fn} ${componentString}`);\n  if (parsed) {\n    const { alpha, components: [type, ...components] } = parsed;\n    return {\n      type,\n      components,\n      alpha\n    };\n  }\n}\nfunction parseCssColorFunction(color) {\n  const match = color.match(/^color\\((.+)\\)$/);\n  if (!match)\n    return;\n  const parsed = parseCssSpaceColorValues(match[1]);\n  if (parsed) {\n    const { alpha, components: [type, ...components] } = parsed;\n    return {\n      type,\n      components,\n      alpha\n    };\n  }\n}\nfunction parseCssSpaceColorValues(componentString) {\n  const components = getStringComponents(componentString, \" \");\n  if (!components)\n    return;\n  let totalComponents = components.length;\n  if (components[totalComponents - 2] === \"/\") {\n    return {\n      components: components.slice(0, totalComponents - 2),\n      alpha: components[totalComponents - 1]\n    };\n  }\n  if (components[totalComponents - 2] != null && (components[totalComponents - 2].endsWith(\"/\") || components[totalComponents - 1].startsWith(\"/\"))) {\n    const removed = components.splice(totalComponents - 2);\n    components.push(removed.join(\" \"));\n    --totalComponents;\n  }\n  const withAlpha = getStringComponents(components[totalComponents - 1], \"/\", 2);\n  if (!withAlpha)\n    return;\n  if (withAlpha.length === 1 || withAlpha[withAlpha.length - 1] === \"\")\n    return { components };\n  const alpha = withAlpha.pop();\n  components[totalComponents - 1] = withAlpha.join(\"/\");\n  return {\n    components,\n    alpha\n  };\n}\n\nfunction createValueHandler(handlers) {\n  const handler = function(str) {\n    const s = this.__options?.sequence || [];\n    this.__options.sequence = [];\n    for (const n of s) {\n      const res = handlers[n](str);\n      if (res != null)\n        return res;\n    }\n  };\n  function addProcessor(that, name) {\n    if (!that.__options) {\n      that.__options = {\n        sequence: []\n      };\n    }\n    that.__options.sequence.push(name);\n    return that;\n  }\n  for (const name of Object.keys(handlers)) {\n    Object.defineProperty(handler, name, {\n      enumerable: true,\n      get() {\n        return addProcessor(this, name);\n      }\n    });\n  }\n  return handler;\n}\n\nfunction variantMatcher(name, handler) {\n  let re;\n  return {\n    name,\n    match(input, ctx) {\n      if (!re)\n        re = new RegExp(`^${escapeRegExp(name)}(?:${ctx.generator.config.separators.join(\"|\")})`);\n      const match = input.match(re);\n      if (match) {\n        return {\n          matcher: input.slice(match[0].length),\n          handle: (input2, next) => next({\n            ...input2,\n            ...handler(input2)\n          })\n        };\n      }\n    },\n    autocomplete: `${name}:`\n  };\n}\nfunction variantParentMatcher(name, parent) {\n  let re;\n  return {\n    name,\n    match(input, ctx) {\n      if (!re)\n        re = new RegExp(`^${escapeRegExp(name)}(?:${ctx.generator.config.separators.join(\"|\")})`);\n      const match = input.match(re);\n      if (match) {\n        return {\n          matcher: input.slice(match[0].length),\n          handle: (input2, next) => next({\n            ...input2,\n            parent: `${input2.parent ? `${input2.parent} $$ ` : \"\"}${parent}`\n          })\n        };\n      }\n    },\n    autocomplete: `${name}:`\n  };\n}\nfunction variantGetBracket(prefix, matcher, separators) {\n  if (matcher.startsWith(`${prefix}[`)) {\n    const [match, rest] = getBracket(matcher.slice(prefix.length), \"[\", \"]\") ?? [];\n    if (match && rest) {\n      for (const separator of separators) {\n        if (rest.startsWith(separator))\n          return [match, rest.slice(separator.length), separator];\n      }\n      return [match, rest, \"\"];\n    }\n  }\n}\nfunction variantGetParameter(prefix, matcher, separators) {\n  if (matcher.startsWith(prefix)) {\n    const body = variantGetBracket(prefix, matcher, separators);\n    if (body) {\n      const [label = \"\", rest = body[1]] = variantGetParameter(\"/\", body[1], separators) ?? [];\n      return [body[0], rest, label];\n    }\n    for (const separator of separators.filter((x) => x !== \"/\")) {\n      const pos = matcher.indexOf(separator, prefix.length);\n      if (pos !== -1) {\n        const labelPos = matcher.indexOf(\"/\", prefix.length);\n        const unlabelled = labelPos === -1 || pos <= labelPos;\n        return [\n          matcher.slice(prefix.length, unlabelled ? pos : labelPos),\n          matcher.slice(pos + separator.length),\n          unlabelled ? \"\" : matcher.slice(labelPos + 1, pos)\n        ];\n      }\n    }\n  }\n}\n\nexport { colorOpacityToString, colorToString, createValueHandler, getBracket, getStringComponent, getStringComponents, hex2rgba, parseCssColor, variantGetBracket, variantGetParameter, variantMatcher, variantParentMatcher };\n","import { hex2rgba } from '@unocss/preset-mini/utils'\n\nexport default {\n  light: {\n    // 颜色主题\n    'color-scheme': 'light',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#0f0f0f')!.join(' '),\n    '--ui-text': hex2rgba('#fcfcfc')!.join(' '),\n    // 主体\n    '--g-bg': '#f2f2f2',\n    '--g-container-bg': '#fff',\n    '--g-border-color': '#f2f2f2',\n    // 头部\n    '--g-header-bg': '#fff',\n    '--g-header-color': '#0f0f0f',\n    '--g-header-menu-color': '#0f0f0f',\n    '--g-header-menu-hover-bg': '#dde1e3',\n    '--g-header-menu-hover-color': '#0f0f0f',\n    '--g-header-menu-active-bg': '#0f0f0f',\n    '--g-header-menu-active-color': '#fff',\n    // 主导航\n    '--g-main-sidebar-bg': '#f2f2f2',\n    '--g-main-sidebar-menu-color': '#0f0f0f',\n    '--g-main-sidebar-menu-hover-bg': '#dde1e3',\n    '--g-main-sidebar-menu-hover-color': '#0f0f0f',\n    '--g-main-sidebar-menu-active-bg': '#0f0f0f',\n    '--g-main-sidebar-menu-active-color': '#fff',\n    // 次导航\n    '--g-sub-sidebar-bg': '#fff',\n    '--g-sub-sidebar-logo-bg': '#0f0f0f',\n    '--g-sub-sidebar-logo-color': '#fff',\n    '--g-sub-sidebar-menu-color': '#0f0f0f',\n    '--g-sub-sidebar-menu-hover-bg': '#dde1e3',\n    '--g-sub-sidebar-menu-hover-color': '#0f0f0f',\n    '--g-sub-sidebar-menu-active-bg': '#0f0f0f',\n    '--g-sub-sidebar-menu-active-color': '#fff',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a3a3a3',\n    '--g-tabbar-tab-color': '#a3a3a3',\n    '--g-tabbar-tab-hover-bg': '#e5e5e5',\n    '--g-tabbar-tab-hover-color': '#0f0f0f',\n    '--g-tabbar-tab-active-color': '#0f0f0f',\n  },\n  classic: {\n    // 颜色主题\n    'color-scheme': 'light',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#409eff')!.join(' '),\n    '--ui-text': hex2rgba('#fcfcfc')!.join(' '),\n    // 主体\n    '--g-bg': '#f2f2f2',\n    '--g-container-bg': '#fff',\n    '--g-border-color': '#f2f2f2',\n    // 头部\n    '--g-header-bg': '#222b45',\n    '--g-header-color': '#fff',\n    '--g-header-menu-color': '#fff',\n    '--g-header-menu-hover-bg': '#334067',\n    '--g-header-menu-hover-color': '#fff',\n    '--g-header-menu-active-bg': '#334067',\n    '--g-header-menu-active-color': '#fff',\n    // 主导航\n    '--g-main-sidebar-bg': '#222b45',\n    '--g-main-sidebar-menu-color': '#fff',\n    '--g-main-sidebar-menu-hover-bg': '#334067',\n    '--g-main-sidebar-menu-hover-color': '#fff',\n    '--g-main-sidebar-menu-active-bg': '#334067',\n    '--g-main-sidebar-menu-active-color': '#fff',\n    // 次导航\n    '--g-sub-sidebar-bg': '#fff',\n    '--g-sub-sidebar-logo-bg': '#222b45',\n    '--g-sub-sidebar-logo-color': '#fff',\n    '--g-sub-sidebar-menu-color': '#0f0f0f',\n    '--g-sub-sidebar-menu-hover-bg': '#dde1e3',\n    '--g-sub-sidebar-menu-hover-color': '#0f0f0f',\n    '--g-sub-sidebar-menu-active-bg': '#409eff',\n    '--g-sub-sidebar-menu-active-color': '#fff',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a3a3a3',\n    '--g-tabbar-tab-color': '#a3a3a3',\n    '--g-tabbar-tab-hover-bg': '#e5e5e5',\n    '--g-tabbar-tab-hover-color': '#0f0f0f',\n    '--g-tabbar-tab-active-color': '#0f0f0f',\n  },\n  naive: {\n    // 颜色主题\n    'color-scheme': 'light',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#18a058')!.join(' '),\n    '--ui-text': hex2rgba('#fcfcfc')!.join(' '),\n    // 主体\n    '--g-bg': '#f2f2f2',\n    '--g-container-bg': '#fff',\n    '--g-border-color': '#f2f2f2',\n    // 头部\n    '--g-header-bg': '#1d2935',\n    '--g-header-color': '#fff',\n    '--g-header-menu-color': '#fff',\n    '--g-header-menu-hover-bg': '#42b983',\n    '--g-header-menu-hover-color': '#fff',\n    '--g-header-menu-active-bg': '#18a058',\n    '--g-header-menu-active-color': '#fff',\n    // 主导航\n    '--g-main-sidebar-bg': '#1d2935',\n    '--g-main-sidebar-menu-color': '#fff',\n    '--g-main-sidebar-menu-hover-bg': '#42b983',\n    '--g-main-sidebar-menu-hover-color': '#fff',\n    '--g-main-sidebar-menu-active-bg': '#18a058',\n    '--g-main-sidebar-menu-active-color': '#fff',\n    // 次导航\n    '--g-sub-sidebar-bg': '#fff',\n    '--g-sub-sidebar-logo-bg': '#1d2935',\n    '--g-sub-sidebar-logo-color': '#fff',\n    '--g-sub-sidebar-menu-color': '#0f0f0f',\n    '--g-sub-sidebar-menu-hover-bg': '#42b983',\n    '--g-sub-sidebar-menu-hover-color': '#fff',\n    '--g-sub-sidebar-menu-active-bg': '#18a058',\n    '--g-sub-sidebar-menu-active-color': '#fff',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a3a3a3',\n    '--g-tabbar-tab-color': '#a3a3a3',\n    '--g-tabbar-tab-hover-bg': '#e5e5e5',\n    '--g-tabbar-tab-hover-color': '#0f0f0f',\n    '--g-tabbar-tab-active-color': '#0f0f0f',\n  },\n  barbie: {\n    // 颜色主题\n    'color-scheme': 'light',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#ff43bc')!.join(' '),\n    '--ui-text': hex2rgba('#fcfcfc')!.join(' '),\n    // 主体\n    '--g-bg': '#f2f2f2',\n    '--g-container-bg': '#fff',\n    '--g-border-color': '#f2f2f2',\n    // 头部\n    '--g-header-bg': '#ff43bc',\n    '--g-header-color': '#fff',\n    '--g-header-menu-color': '#fff',\n    '--g-header-menu-hover-bg': '#dd39a3',\n    '--g-header-menu-hover-color': '#fff',\n    '--g-header-menu-active-bg': '#dd39a3',\n    '--g-header-menu-active-color': '#fff',\n    // 主导航\n    '--g-main-sidebar-bg': '#ff43bc',\n    '--g-main-sidebar-menu-color': '#fff',\n    '--g-main-sidebar-menu-hover-bg': '#dd39a3',\n    '--g-main-sidebar-menu-hover-color': '#fff',\n    '--g-main-sidebar-menu-active-bg': '#dd39a3',\n    '--g-main-sidebar-menu-active-color': '#fff',\n    // 次导航\n    '--g-sub-sidebar-bg': '#fff',\n    '--g-sub-sidebar-logo-bg': '#ff43bc',\n    '--g-sub-sidebar-logo-color': '#fff',\n    '--g-sub-sidebar-menu-color': '#0f0f0f',\n    '--g-sub-sidebar-menu-hover-bg': '#dd39a3',\n    '--g-sub-sidebar-menu-hover-color': '#fff',\n    '--g-sub-sidebar-menu-active-bg': '#dd39a3',\n    '--g-sub-sidebar-menu-active-color': '#fff',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a3a3a3',\n    '--g-tabbar-tab-color': '#a3a3a3',\n    '--g-tabbar-tab-hover-bg': '#e5e5e5',\n    '--g-tabbar-tab-hover-color': '#0f0f0f',\n    '--g-tabbar-tab-active-color': '#0f0f0f',\n  },\n  winter: {\n    // 颜色主题\n    'color-scheme': 'light',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#a6e4f8')!.join(' '),\n    '--ui-text': hex2rgba('#3e4e68')!.join(' '),\n    // 主体\n    '--g-bg': '#f1f5fe',\n    '--g-container-bg': '#fff',\n    '--g-border-color': '#f2f2f2',\n    // 头部\n    '--g-header-bg': '#fff',\n    '--g-header-color': '#3e4e68',\n    '--g-header-menu-color': '#3e4e68',\n    '--g-header-menu-hover-bg': '#e3e8f2',\n    '--g-header-menu-hover-color': '#3e4e68',\n    '--g-header-menu-active-bg': '#a6e4f8',\n    '--g-header-menu-active-color': '#3e4e68',\n    // 主导航\n    '--g-main-sidebar-bg': '#f1f5fe',\n    '--g-main-sidebar-menu-color': '#3e4e68',\n    '--g-main-sidebar-menu-hover-bg': '#e3e8f2',\n    '--g-main-sidebar-menu-hover-color': '#3e4e68',\n    '--g-main-sidebar-menu-active-bg': '#a6e4f8',\n    '--g-main-sidebar-menu-active-color': '#3e4e68',\n    // 次导航\n    '--g-sub-sidebar-bg': '#fff',\n    '--g-sub-sidebar-logo-bg': '#e3e8f2',\n    '--g-sub-sidebar-logo-color': '#3e4e68',\n    '--g-sub-sidebar-menu-color': '#0f0f0f',\n    '--g-sub-sidebar-menu-hover-bg': '#e3e8f2',\n    '--g-sub-sidebar-menu-hover-color': '#3e4e68',\n    '--g-sub-sidebar-menu-active-bg': '#a6e4f8',\n    '--g-sub-sidebar-menu-active-color': '#3e4e68',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a3a3a3',\n    '--g-tabbar-tab-color': '#a3a3a3',\n    '--g-tabbar-tab-hover-bg': '#e5e5e5',\n    '--g-tabbar-tab-hover-color': '#0f0f0f',\n    '--g-tabbar-tab-active-color': '#0f0f0f',\n  },\n  cyberpunk: {\n    // 颜色主题\n    'color-scheme': 'light',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#dbcb00')!.join(' '),\n    '--ui-text': hex2rgba('#0f0f0f')!.join(' '),\n    // 主体\n    '--g-bg': '#f2f2f2',\n    '--g-container-bg': '#fff',\n    '--g-border-color': '#f2f2f2',\n    // 头部\n    '--g-header-bg': '#fff',\n    '--g-header-color': '#302d12',\n    '--g-header-menu-color': '#302d12',\n    '--g-header-menu-hover-bg': '#dbcb00',\n    '--g-header-menu-hover-color': '#302d12',\n    '--g-header-menu-active-bg': '#dbcb00',\n    '--g-header-menu-active-color': '#302d12',\n    // 主导航\n    '--g-main-sidebar-bg': '#f2f2f2',\n    '--g-main-sidebar-menu-color': '#302d12',\n    '--g-main-sidebar-menu-hover-bg': '#dbcb00',\n    '--g-main-sidebar-menu-hover-color': '#302d12',\n    '--g-main-sidebar-menu-active-bg': '#dbcb00',\n    '--g-main-sidebar-menu-active-color': '#302d12',\n    // 次导航\n    '--g-sub-sidebar-bg': '#fff',\n    '--g-sub-sidebar-logo-bg': '#dbcb00',\n    '--g-sub-sidebar-logo-color': '#302d12',\n    '--g-sub-sidebar-menu-color': '#0f0f0f',\n    '--g-sub-sidebar-menu-hover-bg': '#dbcb00',\n    '--g-sub-sidebar-menu-hover-color': '#302d12',\n    '--g-sub-sidebar-menu-active-bg': '#dbcb00',\n    '--g-sub-sidebar-menu-active-color': '#302d12',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a3a3a3',\n    '--g-tabbar-tab-color': '#a3a3a3',\n    '--g-tabbar-tab-hover-bg': '#e5e5e5',\n    '--g-tabbar-tab-hover-color': '#0f0f0f',\n    '--g-tabbar-tab-active-color': '#0f0f0f',\n  },\n  dark: {\n    // 颜色主题\n    'color-scheme': 'dark',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#e5e5e5')!.join(' '),\n    '--ui-text': hex2rgba('#0f0f0f')!.join(' '),\n    // 主体\n    '--g-bg': '#0a0a0a',\n    '--g-container-bg': '#141414',\n    '--g-border-color': '#15191e',\n    // 头部\n    '--g-header-bg': '#141414',\n    '--g-header-color': '#e5e5e5',\n    '--g-header-menu-color': '#a8a29e',\n    '--g-header-menu-hover-bg': '#141414',\n    '--g-header-menu-hover-color': '#e5e5e5',\n    '--g-header-menu-active-bg': '#e5e5e5',\n    '--g-header-menu-active-color': '#0a0a0a',\n    // 主导航\n    '--g-main-sidebar-bg': '#0a0a0a',\n    '--g-main-sidebar-menu-color': '#a8a29e',\n    '--g-main-sidebar-menu-hover-bg': '#141414',\n    '--g-main-sidebar-menu-hover-color': '#e5e5e5',\n    '--g-main-sidebar-menu-active-bg': '#e5e5e5',\n    '--g-main-sidebar-menu-active-color': '#0a0a0a',\n    // 次导航\n    '--g-sub-sidebar-bg': '#141414',\n    '--g-sub-sidebar-logo-bg': '#0f0f0f',\n    '--g-sub-sidebar-logo-color': '#e5e5e5',\n    '--g-sub-sidebar-menu-color': '#a8a29e',\n    '--g-sub-sidebar-menu-hover-bg': '#0a0a0a',\n    '--g-sub-sidebar-menu-hover-color': '#e5e5e5',\n    '--g-sub-sidebar-menu-active-bg': '#e5e5e5',\n    '--g-sub-sidebar-menu-active-color': '#0a0a0a',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a8a29e',\n    '--g-tabbar-tab-color': '#a8a29e',\n    '--g-tabbar-tab-hover-bg': '#1b1b1b',\n    '--g-tabbar-tab-hover-color': '#e5e5e5',\n    '--g-tabbar-tab-active-color': '#e5e5e5',\n  },\n  dracula: {\n    // 颜色主题\n    'color-scheme': 'dark',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#a6adbb')!.join(' '),\n    '--ui-text': hex2rgba('#242b33')!.join(' '),\n    // 主体\n    '--g-bg': '#272935',\n    '--g-container-bg': '#1d232a',\n    '--g-border-color': '#191E24',\n    // 头部\n    '--g-header-bg': '#191E24',\n    '--g-header-color': '#f8f8f2',\n    '--g-header-menu-color': '#a6adbb',\n    '--g-header-menu-hover-color': '#f8f8f2',\n    '--g-header-menu-hover-bg': '#181920',\n    '--g-header-menu-active-color': '#f8f8f2',\n    '--g-header-menu-active-bg': '#414558',\n    // 主导航\n    '--g-main-sidebar-bg': '#191E24',\n    '--g-main-sidebar-menu-color': '#a6adbb',\n    '--g-main-sidebar-menu-hover-color': '#f8f8f2',\n    '--g-main-sidebar-menu-hover-bg': '#181920',\n    '--g-main-sidebar-menu-active-color': '#f8f8f2',\n    '--g-main-sidebar-menu-active-bg': '#414558',\n    // 次导航\n    '--g-sub-sidebar-bg': '#1d232a',\n    '--g-sub-sidebar-logo-color': '#1d232a',\n    '--g-sub-sidebar-logo-bg': '#a6adbb',\n    '--g-sub-sidebar-menu-color': '#a6adbb',\n    '--g-sub-sidebar-menu-hover-color': '#f8f8f2',\n    '--g-sub-sidebar-menu-hover-bg': '#181920',\n    '--g-sub-sidebar-menu-active-color': '#f8f8f2',\n    '--g-sub-sidebar-menu-active-bg': '#414558',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a6adbb',\n    '--g-tabbar-tab-color': '#a6adbb',\n    '--g-tabbar-tab-hover-color': '#f8f8f2',\n    '--g-tabbar-tab-hover-bg': '#242b33',\n    '--g-tabbar-tab-active-color': '#f8f8f2',\n  },\n  night: {\n    // 颜色主题\n    'color-scheme': 'dark',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#0ca6e9')!.join(' '),\n    '--ui-text': hex2rgba('#242b33')!.join(' '),\n    // 主体\n    '--g-bg': '#0f1729',\n    '--g-container-bg': '#1d283a',\n    '--g-border-color': '#191E24',\n    // 头部\n    '--g-header-bg': '#0f1729',\n    '--g-header-color': '#c8cad0',\n    '--g-header-menu-color': '#a6adbb',\n    '--g-header-menu-hover-color': '#c8cad0',\n    '--g-header-menu-hover-bg': '#1d283a',\n    '--g-header-menu-active-color': '#c8cad0',\n    '--g-header-menu-active-bg': '#1d283a',\n    // 主导航\n    '--g-main-sidebar-bg': '#0f1729',\n    '--g-main-sidebar-menu-color': '#a6adbb',\n    '--g-main-sidebar-menu-hover-color': '#c8cad0',\n    '--g-main-sidebar-menu-hover-bg': '#1d283a',\n    '--g-main-sidebar-menu-active-color': '#c8cad0',\n    '--g-main-sidebar-menu-active-bg': '#1d283a',\n    // 次导航\n    '--g-sub-sidebar-bg': '#1d283a',\n    '--g-sub-sidebar-logo-color': '#1d232a',\n    '--g-sub-sidebar-logo-bg': '#a6adbb',\n    '--g-sub-sidebar-menu-color': '#a6adbb',\n    '--g-sub-sidebar-menu-hover-color': '#c8cad0',\n    '--g-sub-sidebar-menu-hover-bg': '#273449',\n    '--g-sub-sidebar-menu-active-color': '#c8cad0',\n    '--g-sub-sidebar-menu-active-bg': '#0f1729',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a6adbb',\n    '--g-tabbar-tab-color': '#a6adbb',\n    '--g-tabbar-tab-hover-color': '#c8cad0',\n    '--g-tabbar-tab-hover-bg': '#242b33',\n    '--g-tabbar-tab-active-color': '#c8cad0',\n  },\n  luxury: {\n    // 颜色主题\n    'color-scheme': 'dark',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#dca54c')!.join(' '),\n    '--ui-text': hex2rgba('#242b33')!.join(' '),\n    // 主体\n    '--g-bg': '#09090b',\n    '--g-container-bg': '#171618',\n    '--g-border-color': '#191E24',\n    // 头部\n    '--g-header-bg': '#09090b',\n    '--g-header-color': '#dca54c',\n    '--g-header-menu-color': '#dca54c',\n    '--g-header-menu-hover-color': '#dca54c',\n    '--g-header-menu-hover-bg': '#331800',\n    '--g-header-menu-active-color': '#ffe7a3',\n    '--g-header-menu-active-bg': '#331800',\n    // 主导航\n    '--g-main-sidebar-bg': '#09090b',\n    '--g-main-sidebar-menu-color': '#dca54c',\n    '--g-main-sidebar-menu-hover-color': '#dca54c',\n    '--g-main-sidebar-menu-hover-bg': '#331800',\n    '--g-main-sidebar-menu-active-color': '#ffe7a3',\n    '--g-main-sidebar-menu-active-bg': '#331800',\n    // 次导航\n    '--g-sub-sidebar-bg': '#171618',\n    '--g-sub-sidebar-logo-color': '#e3d664',\n    '--g-sub-sidebar-logo-bg': '#09090b',\n    '--g-sub-sidebar-menu-color': '#dca54c',\n    '--g-sub-sidebar-menu-hover-color': '#dca54c',\n    '--g-sub-sidebar-menu-hover-bg': '#331800',\n    '--g-sub-sidebar-menu-active-color': '#ffe7a3',\n    '--g-sub-sidebar-menu-active-bg': '#331800',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a6adbb',\n    '--g-tabbar-tab-color': '#a6adbb',\n    '--g-tabbar-tab-hover-color': '#c8cad0',\n    '--g-tabbar-tab-hover-bg': '#242b33',\n    '--g-tabbar-tab-active-color': '#c8cad0',\n  },\n  synthwave: {\n    // 颜色主题\n    'color-scheme': 'dark',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#58c7f3')!.join(' '),\n    '--ui-text': hex2rgba('#1a272e')!.join(' '),\n    // 主体\n    '--g-bg': '#1a103c',\n    '--g-container-bg': '#221551',\n    '--g-border-color': '#191E24',\n    // 头部\n    '--g-header-bg': '#1a103c',\n    '--g-header-color': '#f9f7fd',\n    '--g-header-menu-color': '#f9f7fd',\n    '--g-header-menu-hover-color': '#f9f7fd',\n    '--g-header-menu-hover-bg': '#221551',\n    '--g-header-menu-active-color': '#f9f7fd',\n    '--g-header-menu-active-bg': '#221551',\n    // 主导航\n    '--g-main-sidebar-bg': '#1a103c',\n    '--g-main-sidebar-menu-color': '#f9f7fd',\n    '--g-main-sidebar-menu-hover-color': '#f9f7fd',\n    '--g-main-sidebar-menu-hover-bg': '#221551',\n    '--g-main-sidebar-menu-active-color': '#f9f7fd',\n    '--g-main-sidebar-menu-active-bg': '#221551',\n    // 次导航\n    '--g-sub-sidebar-bg': '#221551',\n    '--g-sub-sidebar-logo-color': '#f9f7fd',\n    '--g-sub-sidebar-logo-bg': '#1a103c',\n    '--g-sub-sidebar-menu-color': '#f9f7fd',\n    '--g-sub-sidebar-menu-hover-color': '#f9f7fd',\n    '--g-sub-sidebar-menu-hover-bg': '#160e35',\n    '--g-sub-sidebar-menu-active-color': '#f9f7fd',\n    '--g-sub-sidebar-menu-active-bg': '#160e35',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a6adbb',\n    '--g-tabbar-tab-color': '#a6adbb',\n    '--g-tabbar-tab-hover-color': '#c8cad0',\n    '--g-tabbar-tab-hover-bg': '#242b33',\n    '--g-tabbar-tab-active-color': '#c8cad0',\n  },\n  stone: {\n    // 颜色主题\n    'color-scheme': 'dark',\n    // 内置 UI\n    '--ui-primary': hex2rgba('#68d1bf')!.join(' '),\n    '--ui-text': hex2rgba('#1b1a18')!.join(' '),\n    // 主体\n    '--g-bg': '#1b1917',\n    '--g-container-bg': '#282524',\n    '--g-border-color': '#43403c',\n    // 头部\n    '--g-header-bg': '#1b1917',\n    '--g-header-color': '#e7e5e4',\n    '--g-header-menu-color': '#e7e5e4',\n    '--g-header-menu-hover-color': '#e7e5e4',\n    '--g-header-menu-hover-bg': '#282524',\n    '--g-header-menu-active-color': '#e7e5e4',\n    '--g-header-menu-active-bg': '#282524',\n    // 主导航\n    '--g-main-sidebar-bg': '#1b1917',\n    '--g-main-sidebar-menu-color': '#e7e5e4',\n    '--g-main-sidebar-menu-hover-color': '#e7e5e4',\n    '--g-main-sidebar-menu-hover-bg': '#282524',\n    '--g-main-sidebar-menu-active-color': '#e7e5e4',\n    '--g-main-sidebar-menu-active-bg': '#282524',\n    // 次导航\n    '--g-sub-sidebar-bg': '#282524',\n    '--g-sub-sidebar-logo-color': '#e7e5e4',\n    '--g-sub-sidebar-logo-bg': '#1a103c',\n    '--g-sub-sidebar-menu-color': '#e7e5e4',\n    '--g-sub-sidebar-menu-hover-color': '#e7e5e4',\n    '--g-sub-sidebar-menu-hover-bg': '#1b1917',\n    '--g-sub-sidebar-menu-active-color': '#e7e5e4',\n    '--g-sub-sidebar-menu-active-bg': '#1b1917',\n    // 标签栏\n    '--g-tabbar-dividers-bg': '#a6adbb',\n    '--g-tabbar-tab-color': '#a6adbb',\n    '--g-tabbar-tab-hover-color': '#c8cad0',\n    '--g-tabbar-tab-hover-bg': '#282524',\n    '--g-tabbar-tab-active-color': '#c8cad0',\n  },\n}\n"],"names":["escapeRegExp","string","alphaPlaceholders","v","hex2rgba","hex","color","parseHexColor","components","alpha","str","body","digits","s","n","value","themes"],"mappings":"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","x_google_ignoreList":[0,1]}